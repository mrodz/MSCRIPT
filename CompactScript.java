
import java.io.BufferedReader; import java.io.FileReader; import java.io.FileWriter; import java.io.File; import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; import java.util.ArrayList; import java.util.Objects; import java.util.Scanner;

@SuppressWarnings({"SpellCheckingInspection", "unused"}) public class CompactScript {private final File file; private int startLine = 0; private final boolean initialized; private boolean log = false; private final ArrayList<String> returnValue = new ArrayList<>();
    public CompactScript(File file) {if (!file.getPath().endsWith(".txt")) new ScriptingException(String.format("Wrong file type. " + "Required: '.txt', found '%s'", file.getName().contains(".") ? file.getName().substring(file.getName().lastIndexOf('.')) : " "), "Check the file type", 5).printError();
        if (!file.exists()) new ScriptingException(String.format("Could not find the file '%s'", file.getPath()), "Check the file declaration", 5).printError();
        if (!file.canRead()) new ThrownScriptingException("This file is private and cannot be read by this compiler", "Change the access permissions linked to " + file.getName(), 5);
        this.file = file; this.initialized = true; try (Scanner scanner = new Scanner(this.file)) {if (!scanner.hasNext() || !scanner.nextLine().equals("```mscript")) new ScriptingException("This file is not compatible " + "with the TestFile Scanner!", "Make sure to declare the file as an MSCRIPT by using the tools.TestFile.syntax given in the documentation", 4).printError();}
        catch (Exception exception) {new ScriptingException(String.format("Native Error (%s)", exception.getMessage()), 5).printError();}
    }

    public CompactScript(String filePath) {this(new File(filePath));} public CompactScript(File file, boolean logSuccessfulOutputs) {this(file); if (logSuccessfulOutputs && !file.canWrite()) new ThrownScriptingException("This file cannot be edited", "Modify the file accessibility or set <logSuccessfulOutputs> to 'false'", 5); log = logSuccessfulOutputs;} public CompactScript(String filePath, boolean logSuccessfulOutputs) {this(new File(filePath), logSuccessfulOutputs);}

    public String[] read() {
        try (Scanner scanner = new Scanner(this.file); BufferedReader reader = new BufferedReader(new FileReader(this.file)); FileWriter fileWriter = new FileWriter(this.file, true)) {String check = reader.readLine(); if (Objects.isNull(check)) new ScriptingException("Empty file", 2).printError();
            if (hasStart()) {for (int i = 0; i <= startLine; i++) {scanner.nextLine(); reader.readLine();} int maxInputLength = 0; String input; for (int i = startLine; scanner.hasNext(); i++) { input = scanner.next();if (input.isEmpty()) { scanner.nextLine(); } else if (input.startsWith(Character.toString(TextSpecifications.COMMENT.getSymbol()))) {if (input.startsWith(Comment.BULK_OPEN.getSignature())) {if (!input.equals(Comment.BULK_OPEN.getSignature() + Comment.BULK_CLOSE.getSignature())) while (true) {String tempVar; if (scanner.hasNext()) { tempVar = scanner.next(); if (tempVar != null && (tempVar.contains(Comment.BULK_CLOSE.getSignature()))) {if (!tempVar.endsWith(Comment.BULK_CLOSE.getSignature())) {returnValue.add(tempVar.replaceAll(".*!##", ""));} break;}} else break; } } else if (input.startsWith(Comment.BULK_CLOSE.getSignature())) { new ScriptingException("Dangling bulk comment", "Look over written bulk comment declarations", 1).printError(); } else if (input.startsWith(Comment.SINGLE.getSignature())) scanner.nextLine(); } else if (input.startsWith(Character.toString(TextSpecifications.COMMAND.getSymbol()))) {//Root Command?
            switch (Objects.requireNonNull(Keyword.getKeywordFromName(input))) {case START_COMMAND: new ScriptingException(String.format("Found duplicate `@start` parameter on line %d", i), "Remove the duplicate `@start` parameter", 1).printError();case STOP_COMMAND: int c = startLine; do {if (input.equals(check)) {c++; break;} c++; check = reader.readLine();} while (check != null); if (scanner.hasNext()) { while (scanner.hasNext()) { input = scanner.next(); if ((input.length() > 0 && input.replaceAll("\\s++", "").charAt(0) == TextSpecifications.COMMENT.getSymbol()) && !input.matches("\\s++")) {if (input.startsWith(Comment.BULK_OPEN.getSignature())) {if (!input.equals(Comment.BULK_OPEN.getSignature() + Comment.BULK_CLOSE.getSignature())) while (true) {String tempVar; if (scanner.hasNext()) {tempVar = scanner.next(); if (tempVar != null && (tempVar.equals(Comment.BULK_CLOSE.getSignature()))) break;} else break;}} else if (input.startsWith(Comment.BULK_CLOSE.getSignature())) {new ScriptingException("Dangling bulk comment", "Look over written bulk comment declarations", 1).printError();} else if (input.replaceAll("\\s++", "").startsWith(Comment.SINGLE.getSignature())) {scanner.nextLine();} else {new ThrownScriptingException(String.format("Dangling code on line %d (Found: '%s')", c, input), "Remove dangling code", 2);}} else {new ThrownScriptingException(String.format("Dangling code on line %d (Found: '%s')", c, input), "Remove dangling code", 2);}}} printDataStack(returnValue);System.out.printf("%c Found `@stop` parameter on line %d, terminating and returning any data " + "that has been stored.%n%n", Symbols.BOTTOM_BAR_LEFT.getSymbol(), c); return returnValue.toArray(new String[0]);}}
            else if (input.startsWith(Character.toString(TextSpecifications.ANNOTATION.getSymbol()))) {StringBuilder str = new StringBuilder(); String annotation = input.replaceAll("\\*\\[|].*", ""); String str1;if (Keyword.annotationExists('[' + annotation + ']') && input.length() != 1) {str1 = input.substring(3 + annotation.length()); switch (Keyword.getAnnotationFromID("[" + annotation + "]")) { case TEXT_COMMENT_SYMBOL: str.append(Annotation.TEXT_COMMENT_SYMBOL.getActualValue()).append(str1); returnValue.add(str.toString()); break; case TEXT_ROOT_SYMBOL: str.append(Annotation.TEXT_ROOT_SYMBOL.getActualValue()).append(str1); returnValue.add(str.toString()); break; case TEXT_ANNOTATION_SYMBOL: str.append(Annotation.TEXT_ANNOTATION_SYMBOL.getActualValue()).append(str1); returnValue.add(str.toString()); break; case WHITESPACE: str.append(Annotation.WHITESPACE.getActualValue()).append(str1); returnValue.add(str.toString()); break; case STORE_AS_LINE: boolean tagContainsText = Annotation.STORE_AS_LINE.getID().length() + 1 < input.length(); String s = scanner.nextLine(); str.append(tagContainsText ? str1.concat(" ") : str1).append(s.charAt(0) == 32 ? s.substring(1) : s); returnValue.add(str.toString()); break; case GROUP_ENTRIES_OPEN: StringBuilder groupEntryBuilder = new StringBuilder().append('{'); if (str1.length() > 0) groupEntryBuilder.append(str1).append(", "); while (true) {String tempVar; if (scanner.hasNext()) {tempVar = scanner.next(); if (tempVar != null) {if (tempVar.equals(TextSpecifications.ANNOTATION.getSymbol() + Annotation.GROUP_ENTRIES_CLOSE.getID())) {break;} else {groupEntryBuilder.append(tempVar).append(", ");}}} else {break;}} returnValue.add(groupEntryBuilder.substring(0, groupEntryBuilder.length() - 2 > 0 ? groupEntryBuilder.length() - 2 : groupEntryBuilder.length() - 1 > 0 ? groupEntryBuilder.length() - 1 : groupEntryBuilder.length()).concat("}")); break; case GROUP_ENTRIES_CLOSE: new ScriptingException("Dangling data group", "Look over written data group annotations", 1).printError();}} else new ScriptingException(String.format("Unknown annotation: %s", input), "Look at the list of annotations present on GitHub", 4).printError();} else {returnValue.add(input); if (input.length() > maxInputLength) maxInputLength = input.length();}}
            printDataStack(returnValue); System.out.printf("%c End of file%n%n", Symbols.BOTTOM_BAR_LEFT.getSymbol()); if (log) {LocalDateTime now = LocalDateTime.now(); fileWriter.append(String.format("%n%n# This file was read at %s on %s - SUCCESS", DateTimeFormatter.ofPattern("MM/dd/yyyy").format(now), DateTimeFormatter.ofPattern("HH:mm:ss").format(now)));fileWriter.flush(); } }
        } catch (Exception exception) {new ScriptingException(String.format("Native Error (%s)", exception.getMessage()), 5).printError();} return returnValue.toArray(new String[0]);
    }
    private boolean hasStart() {
        try (Scanner scanner = new Scanner(this.file); BufferedReader reader = new BufferedReader(new FileReader(this.file))) {String check = reader.readLine(); scanner.nextLine();if (Objects.isNull(check)) new ScriptingException("Empty file", 2).printError();
            String input;
            for (int i = 1; i <= 5000 && scanner.hasNext(); i++) {
                input = scanner.next(); if (input != null && input.startsWith(Character.toString(TextSpecifications.COMMENT.getSymbol()))) {if (input.startsWith(Comment.BULK_OPEN.getSignature())) {if (!input.equals(Comment.BULK_OPEN.getSignature() + Comment.BULK_CLOSE.getSignature())) while (true) {String tempVar; if (scanner.hasNext()) {tempVar = scanner.next(); if (tempVar != null && (tempVar.equals(Comment.BULK_CLOSE.getSignature()))) {break;}} else {break;}}} else if (input.startsWith(Comment.BULK_CLOSE.getSignature())) {new ScriptingException("Dangling bulk comment", "Look over written bulk comment declarations", 1).printError();} else if (input.startsWith(Comment.SINGLE.getSignature())) {scanner.nextLine();} continue;}if (input != null && input.startsWith(Character.toString(TextSpecifications.COMMAND.getSymbol()))) {if (Keyword.commandExists(input)) {if (Objects.requireNonNull(Keyword.getKeywordFromName(input)) == RootCommand.START_COMMAND) {int c = 0; do {if (input.equals(check)) {startLine = c; break;} c++; check = reader.readLine();} while (check != null); System.out.printf("%c Found `@start` parameter on line %d, gathering entries:%n", Symbols.TOP_BAR_LEFT.getSymbol(), startLine); return true;} else if (Objects.requireNonNull(Keyword.getKeywordFromName(input)) == RootCommand.STOP_COMMAND) {System.out.printf("%c Found a `@stop` parameter on line %d before the program could compile." + "%n%c Closing testing:%n", Symbols.TOP_BAR_LEFT.getSymbol(), i, Symbols.BOTTOM_BAR_LEFT.getSymbol()); return false;}}} else if (input != null && (input.isEmpty() || input.replaceAll("\\s++", "").charAt(0) == TextSpecifications.COMMENT.getSymbol())) {scanner.nextLine();} else {new ScriptingException(String.format("Dangling code on line %d (Found: '%s')", i, input), "Remove dangling code", 2).printError();}}
        } catch (Exception exception) {new ScriptingException(String.format("Native Error (%s)", exception.getMessage()), 5).printError();} new ScriptingException("Could not find parameter `@start` while parsing the file.", "add `@start` to declare where the compiler should start checking your code", 4).printError(); return false;
    }

    private void printDataStack(ArrayList<String> array) {for (int i = 0; i < array.toArray().length; i++) {System.out.printf("%c #%d:%s%s%n", Symbols.MIDDLE_BAR_WITH_PIPE.getSymbol(), i, this.buildSpaces(i < 10 ? 3 : (i < 100 ? 2 : 1)), array.toArray()[i]);}}

    @Deprecated public String getFileInformation() {return String.format("File Information:" + "%nText file size: %d bytes" + "%nText file name: %s" + "%nText file path: %s" + "%nInitialized: %b", this.file.length(), this.file.getName(), this.file.getPath(), this.initialized);}

    private String buildSpaces(int spaces) {StringBuilder s = new StringBuilder(); for (int i = 0; i < spaces; i++) s.append(' '); return s.toString();}

    @Deprecated public File getFile() {return file;}
}

@SuppressWarnings("unused") class ScriptingException {private final String message; private String possibleFix; private int severity = 0;
    @Deprecated public ScriptingException(String message) {this.message = message;} public ScriptingException(String message, int severity) {this.message = message; this.severity = Math.min(severity, 5);}
    public ScriptingException(String message, String possibleFix, int severity) {this.message = message; this.possibleFix = possibleFix; this.severity = severity;} @Deprecated public ScriptingException() {this("undefined error", "unknown", -1);}
    public final void printError() {System.out.printf("%nException: %s%n", this.message); if (java.util.Objects.nonNull(possibleFix)) {System.out.printf("%s Possible Fix: %s%n", getSpaces(1), possibleFix);System.out.printf("%s Severity Level: %d/5%n", getSpaces(2), severity);} else System.out.printf("%s Severity Level: %d/5%n", getSpaces(1), severity); System.exit(-1);}
    @Deprecated public final String getMessage() {return message;} @Deprecated final String getPossibleFix() {return possibleFix;} @Deprecated final int getSeverity() {return severity;}
    private String getSpaces(int spaces) {StringBuilder s = new StringBuilder(); for (int i = 0; i < spaces; i++) s.append(' '); return s.append(Symbols.THICK_BOTTOM_BAR_LEFT.getSymbol()).toString();}
}

@SuppressWarnings("unused") class ThrownScriptingException extends ScriptingException {
    @Deprecated public ThrownScriptingException(String message) {super(message); printError();} public ThrownScriptingException(String message, int severity) {super(message, severity); printError();} public ThrownScriptingException(String message, String possibleFix, int severity) {super(message, possibleFix, severity); printError();}
}

enum Annotation {TEXT_ROOT_SYMBOL("[@]", "@"), TEXT_COMMENT_SYMBOL("[#]", "#"), TEXT_ANNOTATION_SYMBOL("[*]", "*"), WHITESPACE("[_]", " "), STORE_AS_LINE("[^+]", null), GROUP_ENTRIES_OPEN("[{{]", null), GROUP_ENTRIES_CLOSE("[}}]", null);
    private final String ID; private final String represents; Annotation(String ID, String represents) { this.ID = ID; this.represents = represents;}
    public String getID() {return ID;} public String getActualValue() {return represents;}
}

enum Comment {SINGLE(Character.toString(TextSpecifications.COMMENT.getSymbol())), BULK_OPEN(Character.toString(TextSpecifications.COMMENT.getSymbol()) + TextSpecifications.COMMENT.getSymbol() + '!'), BULK_CLOSE('!' + Character.toString(TextSpecifications.COMMENT.getSymbol()) + TextSpecifications.COMMENT.getSymbol());
    private final String signature; Comment(String signature) {this.signature = signature;} public String getSignature() {return this.signature;}
}

enum RootCommand implements Keyword {START_COMMAND(TextSpecifications.COMMAND.getSymbol() + "start"), STOP_COMMAND(TextSpecifications.COMMAND.getSymbol() + "stop");
    String name; RootCommand(String name) {this.name = name;} public String getName() {return name;}
}

interface Keyword {
    static boolean commandExists(String name) {for (RootCommand a : RootCommand.values()) if (a.getName().equals(name)) return true; return false;}
    static boolean annotationExists(String name) {for (Annotation a : Annotation.values()) if (a.getID().equals(name)) return true; return false;}
    static RootCommand getKeywordFromName(String name) {for (RootCommand a : RootCommand.values()) {if (a.getName().equals(name)) return a;} new ScriptingException(String.format("Non-existent Root Command '%s'", name), "Check the documentation for available Root Commands.", 4).printError(); return null; }
    static Annotation getAnnotationFromID(String name) {for (Annotation a : Annotation.values()) if (a.getID().equals(name)) return a; return Annotation.STORE_AS_LINE;}
}

@SuppressWarnings("unused") enum Symbols {THICK_TOP_BAR_LEFT('╔'), THICK_BOTTOM_BAR_LEFT('╚'), THICK_TOP_BAR_RIGHT('╗'), THICK_BOTTOM_BAR_RIGHT('╝'), THICK_MIDDLE_BAR_VERTICAL('║'), THICK_MIDDLE_BAR_HORIZONTAL('═'), THICK_MIDDLE_BAR_WITH_PIPE('╠'), THICK_CROSSED_BARS('╬'), TOP_BAR_LEFT('┌'), BOTTOM_BAR_LEFT('└'), TOP_BAR_RIGHT('┐'), BOTTOM_BAR_RIGHT('┘'), MIDDLE_BAR_VERTICAL('│'), MIDDLE_BAR_HORIZONTAL('─'), MIDDLE_BAR_WITH_PIPE('├'), CROSSED_BARS('┼');
    char symbol; Symbols(char symbol) {this.symbol = symbol;} public char getSymbol() {return symbol;}
}

enum TextSpecifications {COMMAND('@'), ANNOTATION('*'), COMMENT('#');
    private final char symbol; TextSpecifications(char symbol) {this.symbol = symbol;} public char getSymbol() {return symbol;}
}